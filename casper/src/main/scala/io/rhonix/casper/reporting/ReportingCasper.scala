package io.rhonix.casper.reporting

import cats.Parallel
import cats.effect.concurrent.Ref
import cats.effect.{Concurrent, ContextShift, Sync}
import cats.syntax.all._
import com.google.protobuf.ByteString
import io.rhonix.models.syntax._
import io.rhonix.blockstorage.dag.BlockDagStorage
import io.rhonix.casper.PrettyPrinter
import io.rhonix.casper.genesis.Genesis
import io.rhonix.casper.protocol.{
  BlockMessage,
  ProcessedDeploy,
  ProcessedSystemDeploy,
  SystemDeployData
}
import io.rhonix.casper.reporting.ReportingCasper.RhoReportingRspace
import io.rhonix.casper.rholang.BlockRandomSeed
import io.rhonix.casper.syntax._
import io.rhonix.crypto.hash.Blake2b512Random
import io.rhonix.metrics.Metrics.Source
import io.rhonix.metrics.{Metrics, Span}
import io.rhonix.models.{BindPattern, ListParWithRandom, Par, TaggedContinuation}
import io.rhonix.rholang.RholangMetricsSource
import io.rhonix.rholang.interpreter.RhoRuntime.{bootstrapRegistry, createRhoEnv}
import io.rhonix.rholang.interpreter.SystemProcesses.{BlockData, Definition}
import io.rhonix.rholang.interpreter.accounting.{_cost, CostAccounting}
import io.rhonix.rholang.interpreter.{Reduce, ReplayRhoRuntimeImpl}
import io.rhonix.rspace.RSpace.RSpaceStore
import io.rhonix.rspace.ReportingRspace.ReportingEvent
import io.rhonix.rspace.{ReportingRspace, Match => RSpaceMatch}
import io.rhonix.shared.Log

import scala.concurrent.ExecutionContext

/**
  * @param processedDeploy Deploy details
  * @param events Reporting events which were generated by this deploy
  */
final case class DeployReportResult(
    processedDeploy: ProcessedDeploy,
    events: Seq[Seq[ReportingEvent]]
)

/**
  * @param processedSystemDeploy system deploy type
  * @param events Reporting events which were generated by this system deploy
  */
final case class SystemDeployReportResult(
    processedSystemDeploy: SystemDeployData,
    events: Seq[Seq[ReportingEvent]]
)

/**
  * This class is holding the reporting replay events results.
  * @param deployReportResult List of user deploy result
  * @param systemDeployReportResult List of system deploy result
  * @param postStateHash postStateHash which generated by the replay. It is possible that this stateHash is different
  *                      from the stateHash in the blockMessage when there is a bug.
  */
final case class ReplayResult(
    deployReportResult: List[DeployReportResult],
    systemDeployReportResult: List[SystemDeployReportResult],
    postStateHash: ByteString
)

trait ReportingCasper[F[_]] {
  def trace(
      block: BlockMessage
  ): F[ReplayResult]
}

object ReportingCasper {
  def noop[F[_]: Sync]: ReportingCasper[F] = new ReportingCasper[F] {

    override def trace(
        block: BlockMessage
    ): F[ReplayResult] =
      Sync[F].delay(ReplayResult(List.empty, List.empty, ByteString.copyFromUtf8("empty")))
  }

  type RhoReportingRspace[F[_]] =
    ReportingRspace[F, Par, BindPattern, ListParWithRandom, TaggedContinuation]

  def rhoReporter[F[_]: Concurrent: ContextShift: Parallel: BlockDagStorage: Log: Metrics: Span](
      rspaceStore: RSpaceStore[F],
      shardId: String
  )(implicit scheduler: ExecutionContext): ReportingCasper[F] =
    new ReportingCasper[F] {
      override def trace(block: BlockMessage): F[ReplayResult] =
        for {
          reportingRspace <- ReportingRuntime.createReportingRSpace(rspaceStore)
          reportingRuntime <- ReportingRuntime.createReportingRuntime(
                               reportingRspace,
                               shardId
                             )
          preStateHash = block.preStateHash

          // Block with empty justifications is genesis which is build with turned off cost accounting
          withCostAccounting = block.justifications.nonEmpty

          // Set Rholang runtime data
          blockdata = BlockData.fromBlock(block)
          _         <- reportingRuntime.setBlockData(blockdata)

          // Reset runtime (in-memory) state
          _ <- reportingRuntime.reset(preStateHash.toBlake2b256Hash)

          // Replay block deploys with reporting
          rand = BlockRandomSeed.randomGenerator(block)
          res <- replayDeploys(
                  reportingRuntime,
                  block.state.deploys,
                  block.state.systemDeploys,
                  rand,
                  withCostAccounting
                )
        } yield res

      private def replayDeploys(
          runtime: ReportingRuntime[F],
          terms: Seq[ProcessedDeploy],
          systemDeploys: Seq[ProcessedSystemDeploy],
          rand: Blake2b512Random,
          withCostAccounting: Boolean
      ): F[ReplayResult] =
        for {
          res <- terms.zipWithIndex.toList.traverse {
                  case (term, i) =>
                    Log[F].info(s"Replay user deploy ${PrettyPrinter.buildString(term.deploy.sig)}") *>
                      runtime
                        .replayDeployE(withCostAccounting)(term, rand.splitByte(i.toByte))
                        .semiflatMap(_ => runtime.getReport)
                        .getOrElse(Seq.empty)
                        .map(DeployReportResult(term, _))
                }
          termsLength = terms.size
          sysRes <- systemDeploys.zipWithIndex.toList.traverse {
                     case (term, i) =>
                       Log[F].info(s"Replay system deploy ${term.systemDeploy}") *>
                         runtime
                           .replayBlockSystemDeploy(
                             term,
                             rand.splitByte((i + termsLength).toByte)
                           )
                           .semiflatMap(_ => runtime.getReport)
                           .getOrElse(Seq.empty)
                           .map(SystemDeployReportResult(term.systemDeploy, _))
                   }

          checkPoint <- runtime.createCheckpoint

        } yield ReplayResult(res, sysRes, checkPoint.root.toByteString)
    }
}

class ReportingRuntime[F[_]: Sync: Span](
    override val reducer: Reduce[F],
    override val space: RhoReportingRspace[F],
    override val cost: _cost[F],
    override val blockDataRef: Ref[F, BlockData],
    override val mergeChs: Ref[F, Set[Par]]
) extends ReplayRhoRuntimeImpl[F](reducer, space, cost, blockDataRef, mergeChs) {
  def getReport: F[Seq[Seq[ReportingEvent]]] = space.getReport
}

object ReportingRuntime {
  implicit val RuntimeMetricsSource: Source =
    Metrics.Source(RholangMetricsSource, "reportingRuntime")

  def createReportingRSpace[F[_]: Concurrent: ContextShift: Parallel: Log: Metrics: Span](
      store: RSpaceStore[F]
  )(
      implicit scheduler: ExecutionContext
  ): F[RhoReportingRspace[F]] = {
    import io.rhonix.rholang.interpreter.storage._
    implicit val m: RSpaceMatch[F, BindPattern, ListParWithRandom] = matchListPar[F]

    ReportingRspace.create[F, Par, BindPattern, ListParWithRandom, TaggedContinuation](store)
  }

  def createReportingRuntime[F[_]: Concurrent: Log: Metrics: Span: Parallel](
      reporting: RhoReportingRspace[F],
      shardId: String,
      extraSystemProcesses: Seq[Definition[F]] = Seq.empty
  ): F[ReportingRuntime[F]] =
    for {
      cost     <- CostAccounting.emptyCost[F]
      mergeChs <- Ref.of(Set[Par]())
      rhoEnv <- {
        implicit val c = cost
        createRhoEnv(
          reporting,
          mergeChs,
          BlockRandomSeed.nonNegativeMergeableTagName(shardId),
          extraSystemProcesses
        )
      }
      (reducer, blockRef) = rhoEnv
      runtime             = new ReportingRuntime[F](reducer, reporting, cost, blockRef, mergeChs)
      _                   <- bootstrapRegistry(runtime)
    } yield runtime
}
